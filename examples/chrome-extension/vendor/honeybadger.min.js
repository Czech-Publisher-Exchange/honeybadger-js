(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Honeybadger = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var UNKNOWN_FUNCTION = '<unknown>';
    /**
     * This parses the different stack traces and puts them into one format
     * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
     */

    function parse(stackString) {
      var lines = stackString.split('\n');
      return lines.reduce(function (stack, line) {
        var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

        if (parseResult) {
          stack.push(parseResult);
        }

        return stack;
      }, []);
    }
    var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

    function parseChrome(line) {
      var parts = chromeRe.exec(line);

      if (!parts) {
        return null;
      }

      var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

      var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

      var submatch = chromeEvalRe.exec(parts[2]);

      if (isEval && submatch != null) {
        // throw out eval line/column and use top-most line/column number
        parts[2] = submatch[1]; // url

        parts[3] = submatch[2]; // line

        parts[4] = submatch[3]; // column
      }

      return {
        file: !isNative ? parts[2] : null,
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: isNative ? [parts[2]] : [],
        lineNumber: parts[3] ? +parts[3] : null,
        column: parts[4] ? +parts[4] : null
      };
    }

    var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

    function parseWinjs(line) {
      var parts = winjsRe.exec(line);

      if (!parts) {
        return null;
      }

      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }

    var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

    function parseGecko(line) {
      var parts = geckoRe.exec(line);

      if (!parts) {
        return null;
      }

      var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
      var submatch = geckoEvalRe.exec(parts[3]);

      if (isEval && submatch != null) {
        // throw out eval line/column and use top-most line number
        parts[3] = submatch[1];
        parts[4] = submatch[2];
        parts[5] = null; // no column when eval
      }

      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: parts[2] ? parts[2].split(',') : [],
        lineNumber: parts[4] ? +parts[4] : null,
        column: parts[5] ? +parts[5] : null
      };
    }

    var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

    function parseJSC(line) {
      var parts = javaScriptCoreRe.exec(line);

      if (!parts) {
        return null;
      }

      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[4],
        column: parts[5] ? +parts[5] : null
      };
    }

    var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

    function parseNode(line) {
      var parts = nodeRe.exec(line);

      if (!parts) {
        return null;
      }

      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }

    function merge(obj1, obj2) {
        var result = {};
        for (var k in obj1) {
            result[k] = obj1[k];
        }
        for (var k in obj2) {
            result[k] = obj2[k];
        }
        return result;
    }
    function mergeNotice(notice1, notice2) {
        var result = merge(notice1, notice2);
        if (notice1.context && notice2.context) {
            result.context = merge(notice1.context, notice2.context);
        }
        return result;
    }
    function objectIsEmpty(obj) {
        for (var k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
                return false;
            }
        }
        return true;
    }
    function objectIsExtensible(obj) {
        if (typeof Object.isExtensible !== 'function') {
            return true;
        }
        return Object.isExtensible(obj);
    }
    function makeBacktrace(stack, shift) {
        if (shift === void 0) { shift = 0; }
        try {
            var backtrace = parse(stack).map(function (line) {
                return {
                    file: line.file,
                    method: line.methodName,
                    number: line.lineNumber,
                    column: line.column
                };
            });
            backtrace.splice(0, shift);
            return backtrace;
        }
        catch (_err) {
            // TODO: log error
            return [];
        }
    }
    function runBeforeNotifyHandlers(notice, handlers) {
        for (var i = 0, len = handlers.length; i < len; i++) {
            var handler = handlers[i];
            if (handler(notice) === false) {
                return false;
            }
        }
        return true;
    }
    function runAfterNotifyHandlers(notice, handlers, error) {
        if (error === void 0) { error = undefined; }
        for (var i = 0, len = handlers.length; i < len; i++) {
            handlers[i](error, notice);
        }
        return true;
    }
    // Returns a new object with properties from other object.
    function newObject(obj) {
        if (typeof (obj) !== 'object') {
            return {};
        }
        var result = {};
        for (var k in obj) {
            result[k] = obj[k];
        }
        return result;
    }
    function sanitize(obj, maxDepth) {
        if (maxDepth === void 0) { maxDepth = 8; }
        var seenObjects = [];
        function seen(obj) {
            if (!obj || typeof (obj) !== 'object') {
                return false;
            }
            for (var i = 0; i < seenObjects.length; i++) {
                var value = seenObjects[i];
                if (value === obj) {
                    return true;
                }
            }
            seenObjects.push(obj);
            return false;
        }
        function canSerialize(obj) {
            // Functions are TMI and Symbols can't convert to strings.
            if (/function|symbol/.test(typeof (obj))) {
                return false;
            }
            if (obj === null) {
                return false;
            }
            // No prototype, likely created with `Object.create(null)`.
            if (typeof obj === 'object' && typeof obj.hasOwnProperty === 'undefined') {
                return false;
            }
            return true;
        }
        function serialize(obj, depth) {
            if (depth === void 0) { depth = 0; }
            if (depth >= maxDepth) {
                return '[DEPTH]';
            }
            // Inspect invalid types
            if (!canSerialize(obj)) {
                return Object.prototype.toString.call(obj);
            }
            // Halt circular references
            if (seen(obj)) {
                return '[RECURSION]';
            }
            // Serialize inside arrays
            if (Array.isArray(obj)) {
                return obj.map(function (o) { return serialize(o, depth + 1); });
            }
            // Serialize inside objects
            if (typeof (obj) === 'object') {
                var ret = {};
                for (var k in obj) {
                    var v = obj[k];
                    if (Object.prototype.hasOwnProperty.call(obj, k) && (k != null) && (v != null)) {
                        ret[k] = serialize(v, depth + 1);
                    }
                }
                return ret;
            }
            // Return everything else untouched
            return obj;
        }
        return serialize(obj);
    }
    function logger(client) {
        var log = function (method) {
            return function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (method === 'debug' && !client.config.debug) {
                    return;
                }
                args.unshift('[Honeybadger]');
                (_a = client.config.logger)[method].apply(_a, args);
            };
        };
        return {
            log: log('log'),
            info: log('info'),
            debug: log('debug'),
            warn: log('warn'),
            error: log('error')
        };
    }
    /**
     * Converts any object into a notice object (which at minimum has the same
     * properties as Error, but supports additional Honeybadger properties.)
     * @param {!Object} notice
     */
    function makeNotice(thing) {
        var notice;
        if (!thing) {
            notice = {};
        }
        else if (Object.prototype.toString.call(thing) === '[object Error]') {
            var e = thing;
            notice = merge(thing, { name: e.name, message: e.message, stack: e.stack });
        }
        else if (typeof thing === 'object') {
            notice = newObject(thing);
        }
        else {
            var m = String(thing);
            notice = { message: m };
        }
        return notice;
    }
    /**
     * Instrument an existing function inside an object (usually global).
     * @param {!Object} object
     * @param {!String} name
     * @param {!Function} replacement
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function instrument(object, name, replacement) {
        if (!object || !name || !replacement || !(name in object)) {
            return;
        }
        var original = object[name];
        while (original && original.__hb_original) {
            original = original.__hb_original;
        }
        try {
            object[name] = replacement(original);
            object[name].__hb_original = original;
        }
        catch (_e) {
            // Ignores errors like this one:
            //   Error: TypeError: Cannot set property onunhandledrejection of [object Object] which has only a getter
            //   User-Agent: Mozilla/5.0 (Linux; Android 10; SAMSUNG SM-G960F) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/12.1 Chrome/79.0.3945.136 Mobile Safari/537.36
        }
    }
    function endpoint(config, path) {
        var endpoint = config.endpoint.trim().replace(/\/$/, '');
        path = path.trim().replace(/(^\/|\/$)/g, '');
        return endpoint + "/" + path;
    }
    function generateStackTrace() {
        try {
            throw new Error('');
        }
        catch (e) {
            if (e.stack) {
                return e.stack;
            }
        }
        var maxStackSize = 10;
        var stack = [];
        var curr = arguments.callee;
        while (curr && stack.length < maxStackSize) {
            if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                stack.push(RegExp.$1 || '<anonymous>');
            }
            else {
                stack.push('<anonymous>');
            }
            try {
                curr = curr.caller;
            }
            catch (e) {
                break;
            }
        }
        return stack.join('\n');
    }
    function filter(obj, filters) {
        if (!is('Object', obj)) {
            return;
        }
        if (!is('Array', filters)) {
            filters = [];
        }
        var seen = [];
        function filter(obj) {
            var k, newObj;
            if (is('Object', obj) || is('Array', obj)) {
                if (seen.indexOf(obj) !== -1) {
                    return '[CIRCULAR DATA STRUCTURE]';
                }
                seen.push(obj);
            }
            if (is('Object', obj)) {
                newObj = {};
                for (k in obj) {
                    if (filterMatch(k, filters)) {
                        newObj[k] = '[FILTERED]';
                    }
                    else {
                        newObj[k] = filter(obj[k]);
                    }
                }
                return newObj;
            }
            if (is('Array', obj)) {
                return obj.map(function (v) { return filter(v); });
            }
            if (is('Function', obj)) {
                return '[FUNC]';
            }
            return obj;
        }
        return filter(obj);
    }
    function filterMatch(key, filters) {
        for (var i = 0; i < filters.length; i++) {
            if (key.toLowerCase().indexOf(filters[i].toLowerCase()) !== -1) {
                return true;
            }
        }
        return false;
    }
    function is(type, obj) {
        var klass = Object.prototype.toString.call(obj).slice(8, -1);
        return obj !== undefined && obj !== null && klass === type;
    }
    function filterUrl(url, filters) {
        if (!filters) {
            return url;
        }
        if (typeof url !== 'string') {
            return url;
        }
        var _a = url.split(/\?/, 2); _a[0]; var query = _a[1];
        if (!query) {
            return url;
        }
        var result = url;
        query.split(/[&]\s?/).forEach(function (pair) {
            var _a = pair.split('=', 2), key = _a[0], value = _a[1];
            if (filterMatch(key, filters)) {
                result = result.replace(key + "=" + value, key + "=[FILTERED]");
            }
        });
        return result;
    }
    function formatCGIData(vars, prefix) {
        if (prefix === void 0) { prefix = ''; }
        var formattedVars = {};
        Object.keys(vars).forEach(function (key) {
            var formattedKey = prefix + key.replace(/\W/g, '_').toUpperCase();
            formattedVars[formattedKey] = vars[key];
        });
        return formattedVars;
    }

    var notifier = {
        name: 'honeybadger-js',
        url: 'https://github.com/honeybadger-io/honeybadger-js',
        version: '3.0.4'
    };
    var Client = /** @class */ (function () {
        function Client(opts) {
            if (opts === void 0) { opts = {}; }
            this.__pluginsExecuted = false;
            this.__context = {};
            this.__breadcrumbs = [];
            this.__beforeNotifyHandlers = [];
            this.__afterNotifyHandlers = [];
            this.config = __assign({ apiKey: null, endpoint: 'https://api.honeybadger.io', environment: null, hostname: null, projectRoot: null, component: null, action: null, revision: null, reportData: null, breadcrumbsEnabled: true, maxBreadcrumbs: 40, maxObjectDepth: 8, logger: console, developmentEnvironments: ['dev', 'development', 'test'], disabled: false, debug: false, enableUncaught: true, enableUnhandledRejection: true, afterUncaught: function () { return true; }, filters: ['creditcard', 'password'], __plugins: [] }, opts);
            this.logger = logger(this);
        }
        Client.prototype.factory = function (_opts) {
            throw (new Error('Must implement __factory in subclass'));
        };
        Client.prototype.getVersion = function () {
            return notifier.version;
        };
        Client.prototype.configure = function (opts) {
            var _this = this;
            if (opts === void 0) { opts = {}; }
            for (var k in opts) {
                this.config[k] = opts[k];
            }
            if (!this.__pluginsExecuted) {
                this.__pluginsExecuted = true;
                this.config.__plugins.forEach(function (plugin) { return plugin.load(_this); });
            }
            return this;
        };
        Client.prototype.beforeNotify = function (handler) {
            this.__beforeNotifyHandlers.push(handler);
            return this;
        };
        Client.prototype.afterNotify = function (handler) {
            this.__afterNotifyHandlers.push(handler);
            return this;
        };
        Client.prototype.setContext = function (context) {
            if (typeof context === 'object') {
                this.__context = merge(this.__context, context);
            }
            return this;
        };
        Client.prototype.resetContext = function (context) {
            if (typeof context === 'object') {
                this.__context = merge({}, context);
            }
            else {
                this.__context = {};
            }
            return this;
        };
        Client.prototype.notify = function (notice, name, extra) {
            if (name === void 0) { name = undefined; }
            if (extra === void 0) { extra = undefined; }
            if (!this.config.apiKey) {
                this.logger.warn('Unable to send error report: no API key has been configured');
                return false;
            }
            if (this.config.disabled) {
                this.logger.warn('Deprecation warning: instead of `disabled: true`, use `reportData: false` to explicitly disable Honeybadger reporting. (Dropping notice: honeybadger.js is disabled)');
                return false;
            }
            if (!this.__reportData()) {
                this.logger.debug('Dropping notice: honeybadger.js is in development mode');
                return false;
            }
            notice = makeNotice(notice);
            if (name && !(typeof name === 'object')) {
                var n = String(name);
                name = { name: n };
            }
            if (name) {
                notice = mergeNotice(notice, name);
            }
            if (typeof extra === 'object') {
                notice = mergeNotice(notice, extra);
            }
            if (objectIsEmpty(notice)) {
                return false;
            }
            notice = merge(notice, {
                name: notice.name || 'Error',
                context: merge(this.__context, notice.context),
                projectRoot: notice.projectRoot || this.config.projectRoot,
                environment: notice.environment || this.config.environment,
                component: notice.component || this.config.component,
                action: notice.action || this.config.action,
                revision: notice.revision || this.config.revision
            });
            var backtraceShift = 0;
            if (typeof notice.stack !== 'string' || !notice.stack.trim()) {
                notice.stack = generateStackTrace();
                backtraceShift = 2;
            }
            notice.backtrace = makeBacktrace(notice.stack, backtraceShift);
            if (!runBeforeNotifyHandlers(notice, this.__beforeNotifyHandlers)) {
                return false;
            }
            this.addBreadcrumb('Honeybadger Notice', {
                category: 'notice',
                metadata: {
                    message: notice.message,
                    name: notice.name,
                    stack: notice.stack
                }
            });
            notice.__breadcrumbs = this.config.breadcrumbsEnabled ? this.__breadcrumbs.slice() : [];
            return this.__send(notice);
        };
        Client.prototype.addBreadcrumb = function (message, opts) {
            if (!this.config.breadcrumbsEnabled) {
                return;
            }
            opts = opts || {};
            var metadata = newObject(opts.metadata);
            var category = opts.category || 'custom';
            var timestamp = new Date().toISOString();
            this.__breadcrumbs.push({
                category: category,
                message: message,
                metadata: metadata,
                timestamp: timestamp
            });
            var limit = this.config.maxBreadcrumbs;
            if (this.__breadcrumbs.length > limit) {
                this.__breadcrumbs = this.__breadcrumbs.slice(this.__breadcrumbs.length - limit);
            }
            return this;
        };
        Client.prototype.__reportData = function () {
            if (this.config.reportData !== null) {
                return this.config.reportData;
            }
            return !(this.config.environment && this.config.developmentEnvironments.includes(this.config.environment));
        };
        Client.prototype.__send = function (_notice) {
            throw (new Error('Must implement send in subclass'));
        };
        Client.prototype.__buildPayload = function (notice) {
            var headers = filter(notice.headers, this.config.filters) || {};
            var cgiData = filter(__assign(__assign({}, notice.cgiData), formatCGIData(headers, 'HTTP_')), this.config.filters);
            return {
                notifier: notifier,
                breadcrumbs: {
                    enabled: !!this.config.breadcrumbsEnabled,
                    trail: notice.__breadcrumbs || []
                },
                error: {
                    class: notice.name,
                    message: notice.message,
                    backtrace: notice.backtrace,
                    fingerprint: notice.fingerprint
                },
                request: {
                    url: filterUrl(notice.url, this.config.filters),
                    component: notice.component,
                    action: notice.action,
                    context: notice.context,
                    cgi_data: cgiData,
                    params: filter(notice.params, this.config.filters) || {},
                    session: filter(notice.session, this.config.filters) || {}
                },
                server: {
                    project_root: notice.projectRoot,
                    environment_name: notice.environment,
                    revision: notice.revision,
                    hostname: this.config.hostname,
                    time: new Date().toUTCString()
                }
            };
        };
        return Client;
    }());

    /**
     * Converts an HTMLElement into a human-readable string.
     * @param {!HTMLElement} element
     * @return {string}
     */
    function stringNameOfElement(element) {
        if (!element || !element.tagName) {
            return '';
        }
        var name = element.tagName.toLowerCase();
        // Ignore the root <html> element in selectors and events.
        if (name === 'html') {
            return '';
        }
        if (element.id) {
            name += "#" + element.id;
        }
        var stringClassNames = element.getAttribute('class');
        if (stringClassNames) {
            stringClassNames.split(/\s+/).forEach(function (className) {
                name += "." + className;
            });
        }
        ['alt', 'name', 'title', 'type'].forEach(function (attrName) {
            var attr = element.getAttribute(attrName);
            if (attr) {
                name += "[" + attrName + "=\"" + attr + "\"]";
            }
        });
        var siblings = getSiblings(element);
        if (siblings.length > 1) {
            name += ":nth-child(" + (Array.prototype.indexOf.call(siblings, element) + 1) + ")";
        }
        return name;
    }
    function stringSelectorOfElement(element) {
        var name = stringNameOfElement(element);
        if (element.parentNode && element.parentNode.tagName) {
            var parentName = stringSelectorOfElement(element.parentNode);
            if (parentName.length > 0) {
                return parentName + " > " + name;
            }
        }
        return name;
    }
    function stringTextOfElement(element) {
        var text = element.textContent || element.innerText || '';
        if (!text && (element.type === 'submit' || element.type === 'button')) {
            text = element.value;
        }
        return truncate(text.trim(), 300);
    }
    function nativeFetch() {
        if (!window.fetch) {
            return false;
        }
        if (isNative(window.fetch)) {
            return true;
        }
        // If fetch isn't native, it may be wrapped by someone else. Try to get
        // a pristine function from an iframe.
        try {
            var sandbox = document.createElement('iframe');
            sandbox.style.display = 'none';
            document.head.appendChild(sandbox);
            var result = sandbox.contentWindow.fetch && isNative(sandbox.contentWindow.fetch);
            document.head.removeChild(sandbox);
            return result;
        }
        catch (err) {
            if (console && console.warn) {
                console.warn('failed to detect native fetch via iframe: ' + err);
            }
        }
        return false;
    }
    function isNative(func) {
        return func.toString().indexOf('native') !== -1;
    }
    function parseURL(url) {
        // Regexp: https://tools.ietf.org/html/rfc3986#appendix-B
        var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/) || {};
        return {
            protocol: match[2],
            host: match[4],
            pathname: match[5]
        };
    }
    function localURLPathname(url) {
        var parsed = parseURL(url);
        var parsedDocURL = parseURL(document.URL);
        // URL must be relative
        if (!parsed.host || !parsed.protocol) {
            return parsed.pathname;
        }
        // Same domain
        if (parsed.protocol === parsedDocURL.protocol && parsed.host === parsedDocURL.host) {
            return parsed.pathname;
        }
        // x-domain
        return parsed.protocol + "://" + parsed.host + parsed.pathname;
    }
    function decodeCookie(string) {
        var result = {};
        string.split(/[;,]\s?/).forEach(function (pair) {
            var _a = pair.split('=', 2), key = _a[0], value = _a[1];
            result[key] = value;
        });
        return result;
    }
    function encodeCookie(object) {
        if (typeof object !== 'object') {
            return undefined;
        }
        var cookies = [];
        for (var k in object) {
            cookies.push(k + '=' + object[k]);
        }
        return cookies.join(';');
    }
    // Helpers
    function getSiblings(element) {
        try {
            var nodes = element.parentNode.childNodes;
            var siblings_1 = [];
            Array.prototype.forEach.call(nodes, function (node) {
                if (node.tagName && node.tagName === element.tagName) {
                    siblings_1.push(node);
                }
            });
            return siblings_1;
        }
        catch (e) {
            return [];
        }
    }
    function truncate(string, length) {
        if (string.length > length) {
            string = string.substr(0, length) + '...';
        }
        return string;
    }
    // Used to decide which error handling method to use when wrapping async
    // handlers: try/catch, or `window.onerror`. When available, `window.onerror`
    // will provide more information in modern browsers.
    var preferCatch = (function () {
        var preferCatch = true;
        // IE < 10
        if (!window.atob) {
            preferCatch = false;
        }
        // Modern browsers support the full ErrorEvent API
        // See https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
        if (window.ErrorEvent) {
            try {
                if ((new window.ErrorEvent('')).colno === 0) {
                    preferCatch = false;
                }
                // eslint-disable-next-line no-empty
            }
            catch (_e) { }
        }
        return preferCatch;
    })();

    /* eslint-disable prefer-rest-params */
    var ignoreOnError = 0;
    var currentTimeout;
    function ignoreNextOnError() {
        ignoreOnError += 1;
        clearTimeout(currentTimeout);
        currentTimeout = setTimeout(function () {
            ignoreOnError = 0;
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function onError(_window) {
        if (_window === void 0) { _window = window; }
        return {
            load: function (client) {
                instrument(_window, 'onerror', function (original) {
                    var onerror = function (msg, url, line, col, err) {
                        client.logger.debug('window.onerror callback invoked', arguments);
                        if (ignoreOnError > 0) {
                            client.logger.debug('Ignoring window.onerror (error likely reported earlier)', arguments);
                            ignoreOnError -= 1;
                            return;
                        }
                        if (!client.config.enableUncaught) {
                            return;
                        }
                        if (line === 0 && /Script error\.?/.test(msg)) {
                            // See https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers/onerror#Notes
                            client.logger.info('Ignoring cross-domain script error: enable CORS to track these types of errors', arguments);
                            return;
                        }
                        var notice = makeNotice(err);
                        if (!notice.name) {
                            notice.name = 'window.onerror';
                        }
                        if (!notice.message) {
                            notice.message = msg;
                        }
                        if (!notice.stack) {
                            // Simulate v8 stack
                            notice.stack = [notice.message, '\n    at ? (', url || 'unknown', ':', line || 0, ':', col || 0, ')'].join('');
                        }
                        client.addBreadcrumb((notice.name === 'window.onerror' || !notice.name) ? 'window.onerror' : "window.onerror: " + notice.name, {
                            category: 'error',
                            metadata: {
                                name: notice.name,
                                message: notice.message,
                                stack: notice.stack
                            }
                        });
                        client.notify(notice);
                    };
                    return function (msg, url, line, col, err) {
                        onerror(msg, url, line, col, err);
                        if (typeof original === 'function') {
                            return original.apply(window, arguments);
                        }
                        return false;
                    };
                });
            }
        };
    }

    /* eslint-disable prefer-rest-params */
    function onUnhandlerRejection (_window) {
        if (_window === void 0) { _window = window; }
        return {
            load: function (client) {
                if (!client.config.enableUnhandledRejection) {
                    return;
                }
                instrument(_window, 'onunhandledrejection', function (original) {
                    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event
                    function onunhandledrejection(promiseRejectionEvent) {
                        client.logger.debug('window.onunhandledrejection callback invoked', arguments);
                        if (!client.config.enableUnhandledRejection) {
                            return;
                        }
                        var reason = promiseRejectionEvent.reason;
                        if (reason instanceof Error) {
                            // simulate v8 stack
                            // const fileName = reason.fileName || 'unknown'
                            // const lineNumber = reason.lineNumber || 0
                            var fileName = 'unknown';
                            var lineNumber = 0;
                            var stackFallback = reason.message + "\n    at ? (" + fileName + ":" + lineNumber + ")";
                            var stack = reason.stack || stackFallback;
                            var err = {
                                name: reason.name,
                                message: "UnhandledPromiseRejectionWarning: " + reason,
                                stack: stack
                            };
                            client.addBreadcrumb("window.onunhandledrejection: " + err.name, {
                                category: 'error',
                                metadata: err
                            });
                            client.notify(err);
                            return;
                        }
                        var message = typeof reason === 'string' ? reason : JSON.stringify(reason);
                        client.notify({
                            name: 'window.onunhandledrejection',
                            message: "UnhandledPromiseRejectionWarning: " + message
                        });
                    }
                    return function (promiseRejectionEvent) {
                        onunhandledrejection(promiseRejectionEvent);
                        if (typeof original === 'function') {
                            original.apply(this, arguments);
                        }
                    };
                });
            }
        };
    }

    /* eslint-disable prefer-rest-params */
    function breadcrumbs (_window) {
        if (_window === void 0) { _window = window; }
        return {
            load: function (client) {
                function breadcrumbsEnabled(type) {
                    if (client.config.breadcrumbsEnabled === true) {
                        return true;
                    }
                    if (type) {
                        return client.config.breadcrumbsEnabled[type] === true;
                    }
                    return client.config.breadcrumbsEnabled !== false;
                }
                // Breadcrumbs: instrument console
                (function () {
                    if (!breadcrumbsEnabled('console')) {
                        return;
                    }
                    function inspectArray(obj) {
                        if (!Array.isArray(obj)) {
                            return '';
                        }
                        return obj.map(function (value) {
                            try {
                                return String(value);
                            }
                            catch (e) {
                                return '[unknown]';
                            }
                        }).join(' ');
                    }
                    ['debug', 'info', 'warn', 'error', 'log'].forEach(function (level) {
                        instrument(_window.console, level, function (original) {
                            return function () {
                                var args = Array.prototype.slice.call(arguments);
                                var message = inspectArray(args);
                                var opts = {
                                    category: 'log',
                                    metadata: {
                                        level: level,
                                        arguments: sanitize(args, 3)
                                    }
                                };
                                client.addBreadcrumb(message, opts);
                                if (typeof original === 'function') {
                                    Function.prototype.apply.call(original, _window.console, arguments);
                                }
                            };
                        });
                    });
                })();
                // Breadcrumbs: instrument click events
                (function () {
                    if (!breadcrumbsEnabled('dom')) {
                        return;
                    }
                    _window.addEventListener('click', function (event) {
                        var message, selector, text;
                        try {
                            message = stringNameOfElement(event.target);
                            selector = stringSelectorOfElement(event.target);
                            text = stringTextOfElement(event.target);
                        }
                        catch (e) {
                            message = 'UI Click';
                            selector = '[unknown]';
                            text = '[unknown]';
                        }
                        // There's nothing to display
                        if (message.length === 0) {
                            return;
                        }
                        client.addBreadcrumb(message, {
                            category: 'ui.click',
                            metadata: {
                                selector: selector,
                                text: text,
                                event: event
                            }
                        });
                    }, true);
                })();
                // Breadcrumbs: instrument XMLHttpRequest
                (function () {
                    if (!breadcrumbsEnabled('network')) {
                        return;
                    }
                    // -- On xhr.open: capture initial metadata
                    instrument(XMLHttpRequest.prototype, 'open', function (original) {
                        return function () {
                            // eslint-disable-next-line @typescript-eslint/no-this-alias
                            var xhr = this;
                            var url = arguments[1];
                            var method = typeof arguments[0] === 'string' ? arguments[0].toUpperCase() : arguments[0];
                            var message = method + " " + localURLPathname(url);
                            this.__hb_xhr = {
                                type: 'xhr',
                                method: method,
                                url: url,
                                message: message
                            };
                            if (typeof original === 'function') {
                                original.apply(xhr, arguments);
                            }
                        };
                    });
                    // -- On xhr.send: set up xhr.onreadystatechange to report breadcrumb
                    instrument(XMLHttpRequest.prototype, 'send', function (original) {
                        return function () {
                            // eslint-disable-next-line @typescript-eslint/no-this-alias
                            var xhr = this;
                            function onreadystatechangeHandler() {
                                if (xhr.readyState === 4) {
                                    var message = void 0;
                                    if (xhr.__hb_xhr) {
                                        xhr.__hb_xhr.status_code = xhr.status;
                                        message = xhr.__hb_xhr.message;
                                        delete xhr.__hb_xhr.message;
                                    }
                                    client.addBreadcrumb(message || 'XMLHttpRequest', {
                                        category: 'request',
                                        metadata: xhr.__hb_xhr
                                    });
                                }
                            }
                            if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                                instrument(xhr, 'onreadystatechange', function (original) {
                                    return function () {
                                        onreadystatechangeHandler();
                                        if (typeof original === 'function') {
                                            // eslint-disable-next-line prefer-rest-params
                                            original.apply(this, arguments);
                                        }
                                    };
                                });
                            }
                            else {
                                xhr.onreadystatechange = onreadystatechangeHandler;
                            }
                            if (typeof original === 'function') {
                                // eslint-disable-next-line prefer-rest-params
                                original.apply(xhr, arguments);
                            }
                        };
                    });
                })();
                // Breadcrumbs: instrument fetch
                (function () {
                    if (!breadcrumbsEnabled('network')) {
                        return;
                    }
                    if (!nativeFetch()) {
                        // Polyfills use XHR.
                        return;
                    }
                    instrument(_window, 'fetch', function (original) {
                        return function () {
                            // eslint-disable-next-line prefer-rest-params
                            var input = arguments[0];
                            var method = 'GET';
                            var url;
                            if (typeof input === 'string') {
                                url = input;
                            }
                            else if ('Request' in _window && input instanceof Request) {
                                url = input.url;
                                if (input.method) {
                                    method = input.method;
                                }
                            }
                            else {
                                url = String(input);
                            }
                            if (arguments[1] && arguments[1].method) {
                                method = arguments[1].method;
                            }
                            if (typeof method === 'string') {
                                method = method.toUpperCase();
                            }
                            var message = method + " " + localURLPathname(url);
                            var metadata = {
                                type: 'fetch',
                                method: method,
                                url: url
                            };
                            return original
                                .apply(this, arguments)
                                .then(function (response) {
                                metadata['status_code'] = response.status;
                                client.addBreadcrumb(message, {
                                    category: 'request',
                                    metadata: metadata
                                });
                                return response;
                            })
                                .catch(function (error) {
                                client.addBreadcrumb('fetch error', {
                                    category: 'error',
                                    metadata: metadata
                                });
                                throw error;
                            });
                        };
                    });
                })();
                // Breadcrumbs: instrument navigation
                (function () {
                    if (!breadcrumbsEnabled('navigation')) {
                        return;
                    }
                    // The last known href of the current page
                    var lastHref = _window.location.href;
                    function recordUrlChange(from, to) {
                        lastHref = to;
                        client.addBreadcrumb('Page changed', {
                            category: 'navigation',
                            metadata: {
                                from: from,
                                to: to
                            }
                        });
                    }
                    // https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
                    instrument(_window, 'onpopstate', function (original) {
                        return function () {
                            recordUrlChange(lastHref, _window.location.href);
                            if (original) {
                                return original.apply(this, arguments);
                            }
                        };
                    });
                    // https://developer.mozilla.org/en-US/docs/Web/API/History/pushState
                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
                    function historyWrapper(original) {
                        return function () {
                            var url = arguments.length > 2 ? arguments[2] : undefined;
                            if (url) {
                                recordUrlChange(lastHref, String(url));
                            }
                            return original.apply(this, arguments);
                        };
                    }
                    instrument(_window.history, 'pushState', historyWrapper);
                    instrument(_window.history, 'replaceState', historyWrapper);
                })();
            }
        };
    }

    /* eslint-disable prefer-rest-params */
    function timers (_window) {
        if (_window === void 0) { _window = window; }
        return {
            load: function (client) {
                // Wrap timers
                (function () {
                    function instrumentTimer(wrapOpts) {
                        return function (original) {
                            // See https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout
                            return function (func, delay) {
                                if (typeof func === 'function') {
                                    var args_1 = Array.prototype.slice.call(arguments, 2);
                                    func = client.__wrap(func, wrapOpts);
                                    return original(function () {
                                        func.apply(void 0, args_1);
                                    }, delay);
                                }
                                else {
                                    return original(func, delay);
                                }
                            };
                        };
                    }
                    instrument(_window, 'setTimeout', instrumentTimer({ component: 'setTimeout' }));
                    instrument(_window, 'setInterval', instrumentTimer({ component: 'setInterval' }));
                })();
            }
        };
    }

    function eventListeners (_window) {
        if (_window === void 0) { _window = window; }
        return {
            load: function (client) {
                // Wrap event listeners
                // Event targets borrowed from bugsnag-js:
                // See https://github.com/bugsnag/bugsnag-js/blob/d55af916a4d3c7757f979d887f9533fe1a04cc93/src/bugsnag.js#L542
                var targets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
                targets.forEach(function (prop) {
                    var prototype = _window[prop] && _window[prop].prototype;
                    if (prototype && Object.prototype.hasOwnProperty.call(prototype, 'addEventListener')) {
                        instrument(prototype, 'addEventListener', function (original) {
                            var wrapOpts = { component: prop + ".prototype.addEventListener" };
                            // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
                            return function (type, listener, useCapture, wantsUntrusted) {
                                try {
                                    if (listener && listener.handleEvent != null) {
                                        listener.handleEvent = client.__wrap(listener.handleEvent, wrapOpts);
                                    }
                                }
                                catch (e) {
                                    // Ignore 'Permission denied to access property "handleEvent"' errors.
                                    client.logger.error(e);
                                }
                                return original.call(this, type, client.__wrap(listener, wrapOpts), useCapture, wantsUntrusted);
                            };
                        });
                        instrument(prototype, 'removeEventListener', function (original) {
                            return function (type, listener, useCapture, wantsUntrusted) {
                                original.call(this, type, listener, useCapture, wantsUntrusted);
                                return original.call(this, type, client.__wrap(listener), useCapture, wantsUntrusted);
                            };
                        });
                    }
                });
            }
        };
    }

    var Honeybadger = /** @class */ (function (_super) {
        __extends(Honeybadger, _super);
        function Honeybadger(opts) {
            if (opts === void 0) { opts = {}; }
            var _this = _super.call(this, __assign({ async: true, maxErrors: null, projectRoot: window.location.protocol + '//' + window.location.host }, opts)) || this;
            _this.__errorsSent = 0;
            _this.__lastWrapErr = undefined;
            _this.__beforeNotifyHandlers = [
                function (notice) {
                    if (_this.__exceedsMaxErrors()) {
                        _this.logger.debug('Dropping notice: max errors exceeded', notice);
                        return false;
                    }
                    if (!notice.url) {
                        notice.url = document.URL;
                    }
                    return true;
                }
            ];
            return _this;
        }
        Honeybadger.prototype.resetMaxErrors = function () {
            return (this.__errorsSent = 0);
        };
        Honeybadger.prototype.factory = function (opts) {
            return new Honeybadger(opts);
        };
        Honeybadger.prototype.__buildPayload = function (notice) {
            var cgiData = {
                HTTP_USER_AGENT: undefined,
                HTTP_REFERER: undefined,
                HTTP_COOKIE: undefined
            };
            cgiData.HTTP_USER_AGENT = navigator.userAgent;
            if (document.referrer.match(/\S/)) {
                cgiData.HTTP_REFERER = document.referrer;
            }
            var cookiesObject;
            if (typeof notice.cookies === 'string') {
                cookiesObject = decodeCookie(notice.cookies);
            }
            else {
                cookiesObject = notice.cookies;
            }
            if (cookiesObject) {
                cgiData.HTTP_COOKIE = encodeCookie(filter(cookiesObject, this.config.filters));
            }
            var payload = _super.prototype.__buildPayload.call(this, notice);
            payload.request.cgi_data = merge(cgiData, payload.request.cgi_data);
            return payload;
        };
        Honeybadger.prototype.__send = function (notice) {
            var _this = this;
            this.__incrementErrorsCount();
            var payload = this.__buildPayload(notice);
            var handlers = Array.prototype.slice.call(this.__afterNotifyHandlers);
            if (notice.afterNotify) {
                handlers.unshift(notice.afterNotify);
            }
            try {
                var x_1 = new XMLHttpRequest();
                x_1.open('POST', endpoint(this.config, '/v1/notices/js'), this.config.async);
                x_1.setRequestHeader('X-API-Key', this.config.apiKey);
                x_1.setRequestHeader('Content-Type', 'application/json');
                x_1.setRequestHeader('Accept', 'text/json, application/json');
                x_1.send(JSON.stringify(sanitize(payload, this.config.maxObjectDepth)));
                x_1.onload = function () {
                    if (x_1.status !== 201) {
                        runAfterNotifyHandlers(notice, handlers, new Error("Bad HTTP response: " + x_1.status));
                        _this.logger.debug("Unable to send error report: " + x_1.status + ": " + x_1.statusText, x_1, notice);
                        return;
                    }
                    runAfterNotifyHandlers(merge(notice, {
                        id: JSON.parse(x_1.response).id
                    }), handlers);
                    _this.logger.debug('Error report sent', notice);
                };
            }
            catch (err) {
                runAfterNotifyHandlers(notice, handlers, err);
                this.logger.error('Unable to send error report: error while initializing request', err, notice);
            }
            return true;
        };
        // wrap always returns the same function so that callbacks can be removed via
        // removeEventListener.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Honeybadger.prototype.__wrap = function (f, opts) {
            if (opts === void 0) { opts = {}; }
            var func = f;
            if (!opts) {
                opts = {};
            }
            try {
                if (typeof func !== 'function') {
                    return func;
                }
                if (!objectIsExtensible(func)) {
                    return func;
                }
                if (!func.___hb) {
                    // eslint-disable-next-line @typescript-eslint/no-this-alias
                    var client_1 = this;
                    func.___hb = function () {
                        var onErrorEnabled = client_1.config.enableUncaught;
                        // Catch if:
                        //   1. We explicitly want to catch (i.e. if the error could be
                        //      caught before reaching window.onerror)
                        //   2. The browser provides less information via the window.onerror
                        //      handler
                        //   3. The window.onerror handler is unavailable
                        if (opts.catch || preferCatch || !onErrorEnabled) {
                            try {
                                // eslint-disable-next-line prefer-rest-params
                                return func.apply(this, arguments);
                            }
                            catch (err) {
                                if (client_1.__lastWrapErr === err) {
                                    throw (err);
                                }
                                client_1.__lastWrapErr = err;
                                ignoreNextOnError();
                                client_1.addBreadcrumb(opts.component ? opts.component + ": " + err.name : err.name, {
                                    category: 'error',
                                    metadata: {
                                        message: err.message,
                                        name: err.name,
                                        stack: err.stack
                                    }
                                });
                                client_1.notify(err);
                                throw (err);
                            }
                        }
                        else {
                            // eslint-disable-next-line prefer-rest-params
                            return func.apply(this, arguments);
                        }
                    };
                }
                func.___hb.___hb = func.___hb;
                return func.___hb;
            }
            catch (_e) {
                return func;
            }
        };
        Honeybadger.prototype.__incrementErrorsCount = function () {
            return this.__errorsSent++;
        };
        Honeybadger.prototype.__exceedsMaxErrors = function () {
            return this.config.maxErrors && this.__errorsSent >= this.config.maxErrors;
        };
        return Honeybadger;
    }(Client));
    var browser = new Honeybadger({
        __plugins: [
            onError(),
            onUnhandlerRejection(),
            timers(),
            eventListeners(),
            breadcrumbs()
        ]
    });

    return browser;

})));
//# sourceMappingURL=honeybadger.js.map
